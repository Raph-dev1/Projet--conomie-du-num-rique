import pandas as pd
import random

# Charger la base de données "individus_bdd"
df = pd.read_csv("individus_bdd.csv")

# Ajouter une colonne "Âge" avec des valeurs aléatoires entre 18 et 99
df['Âge'] = [random.randint(18, 99) for _ in range(len(df))]

# Sélectionner 150 individus aléatoires
def select_random_individuals(df, count=150):
    if len(df) < count:
        print("Le DataFrame contient moins de 150 individus, tous seront inclus.")
        return df
    return df.sample(n=count, random_state=42)

# Sélectionner les individus finaux
Individus_EXP = select_random_individuals(df)

# Sauvegarder les fichiers

Individus_EXP.to_csv("individus_EXP.csv", index=False)  # Fichier avec les 150 individus sélectionnés
print("Fichier individus_finaux.csv généré.")

#Ce code génère un sample de 150 individus, avec un age aléatoire ( 18 à 99 ans)







import os
import pandas as pd
import json
import time
from mistralai import Mistral
import xml.etree.ElementTree as ET

# Initialisation avec votre clé API
api_key = "xxxxxxxxxxxxxxxxxx"
model = "mistral-large-latest"
client = Mistral(api_key=api_key)

# Charger la base de données "Individus_EXP"
df = pd.read_csv("Individus_EXP.csv")

# Fonction pour demander à Mistral d'associer un profil logique
def get_logical_profile(prenom, age, retries=3, cooldown=30):
    prompt = f"""
    Associez un profil réaliste et cohérent pour un individu avec les caractéristiques suivantes :
    - Prénom : {prenom}
    - Âge : {age}
    
    Les variables à attribuer sont strictement :
    - Statut matrimonial : Divorcé, Veuf, Marié, Célibataire.
    - Niveau éducation : Pas de diplôme, Doctorat, Licence, Bac, Master.
    - Statut professionnel : Indépendant, Retraité, Étudiant, Salarié, Chômeur.
    - Quartier : Banlieue, Zone industrielle, Centre-ville.
    - Revenu : <20k€, 20-40k€, 40-60k€, >60k€.
    - Statut logement : Locataire, Propriétaire.
    - Type de logement : Maison, Appartement.
    - Mode de transport : Vélo, Transport en commun, Voiture personnelle, Covoiturage, Télétravail, À pied.
    - Distance domicile-travail : Moins de 1 km, 1-5 km, 5-10 km, Plus de 10 km.
    - Affiliation politique : , droite, centre, gauche.
    - Priorités politiques : Éducation, Environnement, Économie, Sécurité, Santé.
    - Participation électorale : Régulière, Occasionnelle, Jamais.
    - Fréquence de discussions politiques : Faible, Moyenne, Élevée.
    - Confiance dans les institutions (tu dois le faire aléatoirement) : Faible, Moyenne, Forte.
    - Engagement politique : Oui, Non.
    - Influence sociale : Isolé, Leader, Suiveur.
    - Taille du réseau social : Petit, Moyen, Grand.
    - Activité en ligne : Actif, Passif, Inactif.
    - Opinion sur l'immigration : Négative, Positive, Neutre.
    - Opinion sur la fiscalité : Pour une baisse, Pour une hausse, Neutre.
    - Opinion sur les énergies : Fossiles, Renouvelables, Mixte.
    - Probabilité de changer d'avis : Faible, Moyenne, Élevée.
    - Réactivité aux campagnes : Faible, Moyenne, Forte.
    - Interactions interquartiers : Rare, Moyenne, Fréquente.
    - Nombre d'enfants : 0, 1, 2, 3, 4.

    Fournissez une réponse au format XML compact avec les variables ci-dessus.
    """
    for attempt in range(retries):
        try:
            response = client.chat.complete(
                model=model,
                messages=[{"role": "user", "content": prompt}],
            )
            return response.choices[0].message.content
        except Exception as e:
            print(f"Erreur pour {prenom} ({age} ans) : {e}")
            if "429" in str(e):  # Gestion de la limite d'appels
                print(f"Limite atteinte, attente de {cooldown} secondes...")
                time.sleep(cooldown)
            else:
                break
    return "<error></error>"  # Retourne un XML vide en cas d'erreur

# Utiliser DataFrame.itertuples pour accélérer les boucles
profiles = []
brutes = []  # Collecter les réponses brutes non XML

total_individuals = len(df)

for index, row in enumerate(df.itertuples(index=False), start=1):
    print(f"Traitement de {row.Prenom} ({getattr(row, 'Âge')} ans), {index}/{total_individuals}...")
    profile_xml = get_logical_profile(row.Prenom, getattr(row, 'Âge'))  # Correction de l'accès à la colonne Âge
    try:
        # Tenter de parser le XML pour vérifier la validité
        root = ET.fromstring(profile_xml)
        profile_dict = {child.tag: child.text for child in root}
        profiles.append(profile_dict)
    except ET.ParseError:
        print(f"Erreur de décodage XML pour {row.Prenom} ({getattr(row, 'Âge')} ans). Réponse brute : {profile_xml}")
        # Compactage de la réponse brute
        compact_xml = profile_xml.replace("\n", " ").replace("  ", " ").strip()
        profiles.append({})  # Ajouter un profil vide en cas d'erreur
        brutes.append({"Prenom": row.Prenom, "Âge": getattr(row, 'Âge'), "Réponse brute": compact_xml})

# Ajouter les variables au DataFrame
profiles_df = pd.DataFrame(profiles)  # Convertir la liste de profils en DataFrame
df = pd.concat([df, profiles_df], axis=1)  # Fusionner les données originales avec les profils

# Créer un DataFrame pour les réponses brutes
brutes_df = pd.DataFrame(brutes)

# Sauvegarder les fichiers complétés
output_file_path = "Individus_EXP_complet_colonnes.csv"
df.to_csv(output_file_path, index=False)
print(f"Fichier complété généré : {output_file_path}")

if not brutes_df.empty:
    brutes_output_file_path = "Individus_EXP_reponses_brutes.csv"
    brutes_df.to_csv(brutes_output_file_path, index=False)
    print(f"Fichier des réponses brutes généré : {brutes_output_file_path}")







import pandas as pd
import numpy as np

# Génération des données pour les individus
n_individus = 150

df = pd.DataFrame({
    'Âge': np.random.randint(18, 101, n_individus),
    'Sexe': np.random.choice(['Homme', 'Femme'], n_individus),
    'Statut matrimonial': np.random.choice(['Divorcé', 'Veuf', 'Marié', 'Célibataire'], n_individus),
    'Niveau éducation': np.random.choice(['Pas de diplôme', 'Doctorat', 'Licence', 'Bac', 'Master'], n_individus),
    'Statut professionnel': np.random.choice(['Indépendant', 'Retraité', 'Étudiant', 'Salarié', 'Chômeur'], n_individus),
    'Quartier': np.random.choice(['Banlieue', 'Zone industrielle', 'Centre-ville'], n_individus),
    'Revenu': np.random.choice(['<20k€', '20-40k€', '40-60k€', '>60k€'], n_individus),
    'Statut logement': np.random.choice(['Locataire', 'Propriétaire'], n_individus),
    'Type de logement': np.random.choice(['Maison', 'Appartement'], n_individus),
    'Mode de transport': np.random.choice(['Vélo', 'Transport en commun', 'Voiture personnelle', 'Covoiturage', 'Télétravail', 'À pied'], n_individus),
    'Distance domicile-travail': np.random.choice(['Moins de 1 km', '1-5 km', '5-10 km', 'Plus de 10 km'], n_individus),
    'Affiliation politique': np.random.choice(['Indépendant', 'Parti X', 'Non affilié', 'Parti Y'], n_individus),
    'Priorités politiques': np.random.choice(['Éducation', 'Environnement', 'Économie', 'Sécurité', 'Santé'], n_individus),
    'Participation électorale': np.random.choice(['Régulière', 'Occasionnelle', 'Jamais'], n_individus),
    'Fréquence de discussions politiques': np.random.choice(['Faible', 'Moyenne', 'Élevée'], n_individus),
    'Confiance dans les institutions': np.random.randint(1, 6, n_individus),
    'Engagement politique': np.random.choice(['Oui', 'Non'], n_individus),
    'Influence sociale': np.random.choice(['Isolé', 'Leader', 'Suiveur'], n_individus),
    'Taille du réseau social': np.random.choice(['Petit', 'Moyen', 'Grand'], n_individus),
    'Activité en ligne': np.random.choice(['Actif', 'Passif', 'Inactif'], n_individus),
    'Opinion sur l\'immigration': np.random.choice(['Négative', 'Positive', 'Neutre'], n_individus),
    'Opinion sur la fiscalité': np.random.choice(['Pour une baisse', 'Pour une hausse', 'Neutre'], n_individus),
    'Opinion sur les énergies': np.random.choice(['Fossiles', 'Renouvelables', 'Mixte'], n_individus),
    'Probabilité de changer d\'avis': np.random.choice(['Faible', 'Moyenne', 'Élevée'], n_individus),
    'Réactivité aux campagnes': np.random.choice(['Faible', 'Moyenne', 'Forte'], n_individus),
    'Interactions interquartiers': np.random.choice(['Rare', 'Moyenne', 'Fréquente'], n_individus),
    'Nombre d\'enfants': np.random.choice([0, 1, 2, 3, 4, 5], n_individus)
})

# Ajout des scénarios politiques
propositions_data = {
    "Courant politique": ["Gauche", "Gauche", "Gauche", "Centre", "Centre", "Centre", "Droite", "Droite", "Droite"],
    "Valeur principale": ["Égalité sociale", "Solidarité", "Progressisme", "Pragmatisme", "Compromis", "Modération", "Autorité", "Tradition", "Liberté individuelle"],
    "Propositions Initiales": [
        "Augmentation du SMIC à 1500 € net",
        "Création d’un revenu universel d’existence",
        "Légalisation du cannabis",
        "Réduction du nombre de fonctionnaires",
        "Introduction de la proportionnelle",
        "Suppression de la taxe d’habitation",
        "Réduction de l’immigration légale",
        "Défense des valeurs familiales traditionnelles",
        "Allégement de la fiscalité sur les successions"
    ],
    "Propositions Revisitées": [
        "Revaloriser immédiatement le SMIC à 1500 € net pour répondre à l’inflation. Inclut des soutiens aux entreprises.",
        "Mise en place d’un revenu progressif ciblant les jeunes et retraités précaires.",
        "Encadrer et légaliser le cannabis pour investir dans la prévention et l’éducation.",
        "Réduction progressive des effectifs non essentiels avec numérisation des services.",
        "Introduction de la proportionnelle pour une meilleure représentation citoyenne.",
        "Suppression totale avec une réforme fiscale équitable.",
        "Mise en œuvre d’une politique d’intégration pour garantir cohésion et sécurité.",
        "Augmentation des allocations pour familles nombreuses.",
        "Réduction drastique des droits de succession"
    ],
    "Résultats Initiaux": [
        "Mobilisé l’électorat de gauche, contribuant à une dynamique positive pour le candidat.",
        "Novatrice, mais n'a pas suffi à éviter l’élimination du candidat dès le premier tour.",
        "Suscité des débats, mais n'a pas été un facteur déterminant dans les résultats électoraux.",
        "Contribué à l’image réformatrice du candidat, élu président avec 66,1 % des voix au second tour.",
        "Bien accueillie par une partie de l’électorat centriste, cette réforme n'a pas encore été pleinement mise en œuvre.",
        "Populaire et mise en œuvre progressivement durant le quinquennat.",
        "Mobilisé l’électorat de droite, mais le candidat a été battu au second tour.",
        "Consolidé la base électorale traditionnelle, sans toutefois élargir significativement l’électorat.",
        "Malgré cette proposition, le candidat a été éliminé dès le premier tour en raison de scandales judiciaires."
    ]
}

propositions_df = pd.DataFrame(propositions_data)

# Scénarios
scenarios = {
    "Scénario 1": "Propositions initiales réelles pour tous les partis.",
    "Scénario 2 - Gauche": "Optimisation par parti : Gauche applique ses propositions revisitées contre les initiales des autres.",
    "Scénario 2 - Centre": "Optimisation par parti : Centre applique ses propositions revisitées contre les initiales des autres.",
    "Scénario 2 - Droite": "Optimisation par parti : Droite applique ses propositions revisitées contre les initiales des autres.",
    "Scénario 3": "Proposition utopique pour la Gauche (SMIC à 6000 €)."
}

# Fonction d'ajustement des intentions de vote prenant en compte toutes les variables
def adjust_vote_intentions(individual, proposition, is_optimized=False, utopian=False):
    score = 0

    # Influence par le revenu
    if proposition["Courant politique"] == "Gauche" and individual["Revenu"] in ["<20k€", "20-40k€"]:
        score += 3
    elif proposition["Courant politique"] == "Centre" and individual["Revenu"] in ["40-60k€"]:
        score += 3
    elif proposition["Courant politique"] == "Droite" and individual["Revenu"] in [">60k€"]:
        score += 3

    # Influence par l'âge
    if proposition["Courant politique"] == "Gauche" and individual["Âge"] < 30:
        score += 3
    elif proposition["Courant politique"] == "Centre" and 30 <= individual["Âge"] < 50:
        score += 3
    elif proposition["Courant politique"] == "Droite" and individual["Âge"] >= 50:
        score += 3

    # Influence par le niveau d'éducation
    if individual["Niveau éducation"] in ["Pas de diplôme", "Bac"] and proposition["Courant politique"] == "Gauche":
        score += 2
    elif individual["Niveau éducation"] in ["Master", "Doctorat"] and proposition["Courant politique"] == "Droite":
        score += 2

    # Influence par le statut professionnel
    if individual["Statut professionnel"] == "Étudiant" and proposition["Courant politique"] == "Gauche":
        score += 2
    elif individual["Statut professionnel"] == "Retraité" and proposition["Courant politique"] == "Droite":
        score += 2

    # Influence par les opinions
    if individual["Opinion sur l'immigration"] == "Positive" and proposition["Courant politique"] == "Gauche":
        score += 3
    elif individual["Opinion sur l'immigration"] == "Négative" and proposition["Courant politique"] == "Droite":
        score += 3

    # Influence par les priorités politiques
    if individual["Priorités politiques"] == "Santé" and proposition["Courant politique"] == "Gauche":
        score += 3
    elif individual["Priorités politiques"] == "Économie" and proposition["Courant politique"] == "Centre":
        score += 3
    elif individual["Priorités politiques"] == "Sécurité" and proposition["Courant politique"] == "Droite":
        score += 3

    # Influence par la réactivité aux campagnes
    if individual["Réactivité aux campagnes"] == "Forte":
        score += 2

    # Influence par la confiance dans les institutions
    if individual["Confiance dans les institutions"] >= 4 and proposition["Courant politique"] == "Centre":
        score += 3

    # Bonus pour propositions revisitées
    if is_optimized:
        score += 5

    # Bonus pour une proposition utopique
    if utopian:
        score += 8

    return score

# Simulations Monte Carlo avec votes Blanc/Nul dynamiques
def monte_carlo_simulation(iterations, df, propositions_df, scenarios):
    monte_carlo_results = {scenario: [] for scenario in scenarios}

    for _ in range(iterations):
        for scenario, description in scenarios.items():
            vote_intentions = {"Gauche": np.zeros(len(df)), "Centre": np.zeros(len(df)), "Droite": np.zeros(len(df)), "Blanc/Nul": np.zeros(len(df))}

            for index, row in propositions_df.iterrows():
                if scenario == f"Scénario 2 - {row['Courant politique']}":
                    proposition = {"Courant politique": row["Courant politique"], "Propositions Initiales": row["Propositions Revisitées"]}
                    is_optimized = True
                    utopian = False
                elif scenario == "Scénario 3" and row["Courant politique"] == "Gauche":
                    proposition = {"Courant politique": "Gauche", "Propositions Initiales": "SMIC à 6000 €"}
                    is_optimized = False
                    utopian = True
                else:
                    proposition = row
                    is_optimized = False
                    utopian = False

                for i, individual in df.iterrows():
                    score = adjust_vote_intentions(individual, proposition, is_optimized, utopian)
                    if individual["Confiance dans les institutions"] < 3 and np.random.rand() < 0.5:
                        vote_intentions["Blanc/Nul"][i] += 1
                    else:
                        vote_intentions[proposition["Courant politique"]][i] += score

            votes = []
            for i in range(len(df)):
                scores = {party: vote_intentions[party][i] for party in vote_intentions}
                votes.append(max(scores, key=scores.get))

            vote_counts = pd.Series(votes).value_counts().reindex(["Gauche", "Centre", "Droite", "Blanc/Nul"], fill_value=0)
            monte_carlo_results[scenario].append(vote_counts)

    return monte_carlo_results

# Exécution de la simulation Monte Carlo
iterations = 120
monte_carlo_results = monte_carlo_simulation(iterations, df, propositions_df, scenarios)

# Agrégation des résultats
final_results = {}
for scenario, results in monte_carlo_results.items():
    aggregated = pd.DataFrame(results).mean().round(0).astype(int)
    aggregated["Objectif"] = scenarios[scenario]
    final_results[scenario] = aggregated

# Affichage des résultats
for scenario, result in final_results.items():
    print(f"Résultats pour le {scenario} :")
    print(result.to_string())
    print("\n")
